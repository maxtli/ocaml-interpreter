open Expr ;;
  
(* Exception for evaluator runtime, generated by a runtime error in
   the interpreter *)
exception EvalError of string ;;
  
(* Exception for evaluator runtime, generated by an explicit `raise`
   construct in the object language *)
exception EvalException ;;

(*......................................................................
  Environments and values 
 *)

module type ENV = sig
    (* the type of environments *)
    type env
    (* the type of values stored in environments *)
    type value =
      | Val of expr
      | Closure of (expr * env)
   
    (* empty () -- Returns an empty environment *)
    val empty : unit -> env

    (* close expr env -- Returns a closure for `expr` and its `env` *)
    val close : expr -> env -> value

    (* lookup env varid -- Returns the value in the `env` for the
       `varid`, raising an `eval_err` if not found *)
    val lookup : env -> varid -> value

    (* extend env varid loc -- Returns a new environment just like
       `env` except that it maps the variable `varid` to the `value`
       stored at `loc`. *)
    val extend : env -> varid -> value ref -> env

    (* env_to_string env -- Returns a printable string representation
       of environment `env` *)
    val env_to_string : env -> string
                                 
    (* value_to_string ?printenvp value -- Returns a printable string
       representation of a value; the optional flag `printenvp`
       (default: `true`) determines whether to include the environment
       in the string representation when called on a closure *)
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : ENV =
  struct
    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    let empty () : env = []

    let close (exp : expr) (env : env) : value =
      Closure (exp, env)
    
    let lookup (env : env) (varname : varid) : value =
      try !(List.assoc varname env)
      with Not_found -> raise @@ EvalError (varname ^ " not found in environment")

    let extend (env : env) (varname : varid) (loc : value ref) : env =
      (varname, loc) :: List.remove_assoc varname env ;;

    let rec env_to_string (env : env) : string = 
      ", [" ^ List.fold_left (fun acc (varname, value) -> acc ^ "\n" ^ varname ^ " -> " ^ value_to_string !value) "" env ^ "\n]"

    and value_to_string ?(printenvp : bool = true) (v : value) : string = match v with
      | Val exp -> if !Expr.abs then "Val (" ^ exp_to_abstract_string exp ^ ")" else exp_to_concrete_string exp 
      | Closure (exp, env) -> if !Expr.abs then "Closure (" ^ exp_to_abstract_string exp ^ (if printenvp then env_to_string env else "") ^ ")" else exp_to_concrete_string exp
  end
;;


(*......................................................................
  Evaluation functions

   The TRIVIAL EVALUATOR, which leaves the expression to be evaluated
   essentially unchanged, just converted to a value for consistency
   with the signature of the evaluators. *)
   
let eval_t (exp : expr) (_env : Env.env) : Env.value =
  Env.Val exp ;;

let eval_err exp msg =
  raise @@ EvalError (exp_to_concrete_string exp ^ " " ^ msg) ;;

(* Helper function cleans up eval recursion by translating Env.value into an expression *)
let val_reduce = function
  | Env.Val x -> x
  | _ -> raise @@ EvalError "expected value but got closure" ;;

let rec match_type (t1 : literaltype) (t2 : literaltype) = match t1, t2 with
  | _, EmptyList -> t1
  | EmptyList, _ -> t2
  | List t1, List t2 -> List (match_type t1 t2)
  | t1, t2 -> if t1 = t2 then t1 else raise @@ EvalError "list must be of same type" ;;

(* Substitution semantics. *)
let eval_sub (exp : expr) (env : Env.env) (evalf : expr -> Env.env -> Env.value) : Env.value = 
  let eval x = val_reduce @@ evalf x env in
  let lit : Expr.expr -> Expr.literal = (function
    | Literal l -> l
    | _ -> eval_err exp "expected literal") in
  Env.Val (match exp with
    | Literal _
    | Fun _ -> exp

    | Unop (u, e)->
      (* Disabled inexhaustive match case warning -- handled by try. *)
        (try [@warning "-8"] 
          let e = eval e |> lit in
          Literal (match u with
            | Negate -> let Num x = e in Num (~-x)
            | NegateDot -> let Float x = e in Float (~-.x)
            | Not -> let Bool x = e in Bool (not x))
        with Match_failure _ -> eval_err exp "invalid operation")
      
    | Binop (b, e1, e2) ->
      (* Disabled inexhaustive match case warning -- handled by try. *)
        (try [@warning "-8"]
          let e1, e2 = eval e1 |> lit, eval e2 |> lit in
          Literal (match b with
            | Equals -> if get_tag e1 = get_tag e2 then Bool (e1 = e2) else eval_err exp "invalid operation"
            | NotEqual -> if get_tag e1 = get_tag e2 then Bool (e1 <> e2) else eval_err exp "invalid operation"

            | LessThan | GreaterThan | LessEqual | GreaterEqual -> Bool (
              let get_op = (match b with
                | LessThan -> (<)
                | GreaterThan -> (>)
                | LessEqual -> (<=)
                | GreaterEqual -> (>=)) in
              match e1, e2 with
                | Num x, Num y -> get_op x y
                | Float x, Float y -> get_op x y)
                
            | Concat -> let String x, String y = e1, e2 in String (x ^ y)
            | Cons -> let List (xtype, xs) = e2 in List (match_type xtype @@ get_tag e1, e1 :: xs)
            | ListConcat -> let List (xtype, xs), List (ytype, ys) = e1, e2 in List (match_type xtype ytype, xs @ ys)
            | And -> let Bool x, Bool y = e1, e2 in Bool (x && y)
            | Or -> let Bool x, Bool y = e1, e2 in Bool (x || y)
            | Seq -> let Unit = e1 in e2

            | Plus | Minus | Times | Divide ->
              let Num x, Num y = e1, e2 in 
              Num ((match b with 
                | Plus -> (+)
                | Minus -> (-)
                | Times -> ( * )
                | Divide -> (/)) x y)
            | PlusDot | MinusDot | TimesDot | DivideDot | Exponent ->
              let Float x, Float y = e1, e2 in 
              Float ((match b with 
                | PlusDot -> (+.)
                | MinusDot -> (-.)
                | TimesDot -> ( *. )
                | DivideDot -> (/.)
                | Exponent -> ( ** )) x y))
          with 
            | Match_failure _ 
            | Invalid_argument _ -> eval_err exp "invalid operation")
    | Conditional (cond, tr, fal) -> 
      (match eval cond with 
        | Literal (Bool cond) -> eval (if cond then tr else fal)
        | _ -> eval_err exp "expected bool")
    | Match (e, cases) -> 
        let rec pattern_match (accum : (varid * literal) list ref) (e : literal) (pattern: pattern) = 
          (try [@warning "-8"] 
            match pattern with
            | Wildcard -> true
            | Var x -> accum := (x, e) :: !accum;  true
            | Literal l -> e = l
            | List plist -> let List (_, elist) = e in 
                            List.for_all2 (pattern_match accum) elist plist
            | Cons (phead, ptail) -> let List (ltype, ehead :: etail) = e in
                            pattern_match accum ehead phead && pattern_match accum (List (ltype, etail)) ptail
            | Options (left, right) -> 
                let left_accum = ref [] in 
                if pattern_match left_accum e left then
                  (accum := !accum @ !left_accum; true)
                else pattern_match accum e right
          with 
          | Match_failure _ -> false
          | Invalid_argument _ -> false) in
        let rec find_case e = (function
          | (pattern, result) :: t -> 
              ignore @@ pattern_bindings pattern;
              let bindings = ref [] in
              if pattern_match bindings e pattern then
                eval @@ List.fold_left (fun acc (x, lit) -> Let(x, Literal lit, acc)) result !bindings
              else find_case e t
          | _ -> eval_err exp "match failed") in
        cases |> find_case @@ lit @@ eval e
    | Raise -> raise EvalException
    | Unassigned -> eval_err exp "tried to evaluate unassigned"

    | Var _ -> eval_err exp "unbound value"
    | Let (x, def, body) -> 
        body
        |> subst x @@ eval def
        |> eval
    | Letrec (x, def, body) ->
        let recdef = eval def in 
        body
        |> subst x @@ subst x (Letrec (x, recdef, Var x)) recdef
        |> eval
    | App (f, x) -> 
      (match eval f with
        | Fun (param, body) -> 
            body
            |> subst param @@ eval x
            |> eval
        | _ -> eval_err exp "expected function"));;  

let rec eval_s (exp : expr) (env : Env.env) : Env.value = 
  eval_sub exp env eval_s ;;

(* Dynamic environment semantics inherits everything from substitution semantics, except for the listed cases.*)
let eval_env (exp : expr) (env : Env.env) (eval : expr -> Env.env -> Env.value) : Env.value =
  match exp with
    | Var x -> Env.lookup env x
    | Let (x, def, body)
    | Letrec (x, def, body) ->
        ref @@ eval def env
        |> Env.extend env x 
        |> eval body
    | App (f, x) -> 
      (match eval f env with
        | Env.Val (Fun (param, body)) -> 
            ref @@ eval x env
            |> Env.extend env param
            |> eval body
        | _ -> eval_err exp "expected function value")
    | _ -> eval_sub exp env eval
  ;;

let rec eval_d (exp : expr) (env : Env.env) : Env.value = 
  eval_env exp env eval_d ;;

(* Lexical environment semantics inherits everything from dynamic semantics, except for the listed cases. *)
let rec eval_l (exp : expr) (env : Env.env) : Env.value = 
  match exp with 
    | Fun _ -> Env.Closure (exp, env)
    | Letrec (x, def, body) -> 
        let loc = ref @@ Env.Val Unassigned in
        let recenv = Env.extend env x loc in 
        loc := eval_l def recenv; 
        eval_l body recenv
    | App (f, x) ->
      (match eval_l f env with
        | Env.Closure (Fun (param, body), lexenv) ->
          ref @@ eval_l x env
          |> Env.extend lexenv param
          |> eval_l body
        | _ -> eval_err exp "expected closure of function")
    | _ -> eval_env exp env eval_l ;;
     
let evaluate = eval_t ;;